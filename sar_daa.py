# -*- coding: utf-8 -*-
"""SAR_DAA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JhAm0wsxKIYNrbTLWVH-q74CMNdj8yff

# Structural Optimization using Search and Rescue Algorithm
"""

import numpy as np
import matplotlib.pyplot as plt

#Class to perform 3d Truss structure
class Truss:
  def __init__(self, young_modulus, density, node, bar):
    self.young_modulus = young_modulus
    self.density = density
    self.node = node.astype(float)
    self.bar = bar.astype(int)

    self.dof = 3
    self.load = np.zeros_like(node)
    self.support = np.ones_like(node).astype(int)
    self.section = np.ones(len(bar))

    self.stress = np.array(len(bar))
    self.displacement = np.array(len(node))
    self.weight = 0

#Basic function to mperform structural optimization

  def analysis(self):
    nn = len(self.node)
    ne = len(self.bar)
    n_dof = self.dof*nn
    d = self.node[self.bar[:,1],:] - self.node[self.bar[:,0],:]
    length = np.sqrt((d**2).sum(axis=1))
    length = np.array([0.00001 if value == 0 else value for value in length])
    angle = d.T/length
    a = np.concatenate((-angle.T, angle.T), axis=1)
    ss = np.zeros([n_dof, n_dof])

    for k in range(ne):
      aux = self.dof * self.bar[k,:]
      index = np.r_[aux[0]:aux[0] + self.dof, aux[1]:aux[1] + self.dof]
      es = np.dot(a[k][np.newaxis].T * self.young_modulus * self.section[k], a[k][np.newaxis])/ length[k]
      ss[np.ix_(index, index)] = ss[np.ix_(index,index)] + es
    
    free_dof = self.support.flatten().nonzero()[0]
    kff = ss[np.ix_(free_dof, free_dof)]
    pf = self.load.flatten()[free_dof]
    uf = np.linalg.solve(kff,pf)
    u = self.support.astype(float).flatten()
    u[free_dof] = uf
    u = u.reshape(nn, self.dof)
    u_ele = np.concatenate((u[self.bar[:, 0]], u[self.bar[:, 1]]), axis=1)
    force = self.young_modulus * self.section/length*(a*u_ele).sum(axis=1)
    self.stress = force / self.section
    self.displacement = u
    self.weight = (self.density * self.section * length).sum()

#Function to plot the truss structure

  def undeformed(self, properties):
    # properties = [color, linestyle, linewidth]
    color = properties[0]
    linestyle = properties[1]
    linewidth = properties[2]
    plt.figure( 'Structure')
    plt.subplot(projection= '3d')
    for i in range(len(self.bar)):
      xi, xf = self.node[self.bar[i, 0], 0], self.node[self.bar[i, 1], 0]
      yi, yf = self.node[self.bar[i, 0], 1], self.node[self.bar[i, 1], 1]
      zi, zf = self.node[self.bar[i, 0], 2], self.node[self.bar[i, 1], 2]
      plt.plot([xi, xf], [yi, yf], [zi, zf], color=color, linestyle=linestyle, linewidth=linewidth)

#structural optimization using search and rescue algorithm

class SAR:
  def __init__(self, truss, section_list, section_variable, population, iteration, stress_lim, disp_lim):
    self.truss = truss
    self.section_list = section_list
    self.section_variable = section_variable
    self.population = population
    self.iteration = iteration
    self.stress_lim = stress_lim
    self.disp_lim = disp_lim

    self.dimension = len(np.unique(self.section_variable[:,0]))
    self.gbest = np.zeros([iteration + 1, self.dimension])
    self.gbest_cost = np.zeros(iteration + 1)
    self.stress = np.zeros([population, len(truss.bar)])
    self.displacement = np.zeros([population, len(truss.node), truss.dof])

#function to get the weight for finding the cost using static method

  @staticmethod
  def get_weight(truss, position, section_list, section_variable):
    for i in range(len(truss.bar)):
      index = int(position[section_variable[i, 0]])
      truss.section[i] = section_list[index]
    truss.analysis()
    return truss.weight

#function for the bound value using static method

  @staticmethod
  def bound(position_bound, position, position_prime):
     if position_prime > position_bound[1]:
         position_prime = (position + position_bound[1])/2
     if position_prime < position_bound[0]:
         position_prime = (position + position_bound[0])/2
     return position_prime

#function to find the nearst position 

  @staticmethod
  def find_nearest(array, value):
    array = np.asarray(array)
    index = (np.abs(array - value)).argmin() 
    return array[index]

#function to process using the constraints mentioned

  @staticmethod
  def constraint(cost, truss, stress, stress_max, displacement, displacement_max, iteration, max_iter):
    ep1 = np.linspace(1, 15, max_iter)
    ep2 = 2
    c_total = 0
    
    for i in range(len(stress)):
      c_stress = 0
      if np.abs(stress[i]) > stress_max:
        c_stress = np.abs((np.abs(stress[i]) - stress_max) / stress_max)
      
      c_total += c_stress

    for i in range(len(truss.node)):
      c_displacement = 0
      for axis in range(truss.dof):
        if np.abs(displacement[i, axis]) > displacement_max:
          c_displacement = np.abs(np.abs(displacement[i, axis]) - displacement_max) / displacement_max
        c_total += c_displacement

    phi = (1 + ep1[iteration] * c_total) ** ep2
    cost = cost * phi
    return cost

#function to update the values 

  @staticmethod
  def update_info(position, position_cost, position_prime, position_prime_cost, memory, population, usn):
    n = np.random.randint(0, population)
    if position_prime_cost < position_cost:
      memory[n] = position
      position = position_prime
    else:
      usn += 1
    return memory, position, usn

#function for optimization
  def optimization(self):
    section_int = np.linspace(0, len(self.section_list)- 1, len(self.section_list)).astype(int)
    position_bound= np.array([min(section_int), max(section_int)]) * np.ones([self.dimension, 2])

    clue = np.zeros([2 * self.population, self.dimension])
    clue_cost = np.zeros(2*self.population)
    for i in range(2*self.population):
        for j in range(self.dimension):
            clue[i,j] = np.random.choice(section_int[section_int > 20])
        clue_cost[i] = self.get_weight(self.truss, clue[i], self.section_list, self.section_variable)
    clue = clue[np.argsort(clue_cost)]

    self.gbest[0] = clue[0]
    self.gbest_cost[0]  =  np.min(clue_cost)
    position = np.copy(clue[0:self.population])
    position_p = np.copy(position)
    memory =np.copy(clue[self.population:])

    for it in range(self.iteration):
      usn = np.zeros(self.population)
      se = 0.7
      mu  = 30 * self.dimension

      for i in range(self.population):
        k = np.random.randint(0, 2 * self.population)
        while k == i:
          k = np.random.randint(0, 2 * self.population)

        clue_cost_k = self.get_weight(self.truss, clue[k], self.section_list, self.section_variable)
        position_cost = self.get_weight(self.truss, position[i], self.section_list, self.section_variable)

        if np.random.rand() < 0.5:
          r1 =np.random.uniform(-1, 1)
          for j in range(self.dimension):
            r2 = np.random.rand()
            j_rand = np.random.randint(0,self.dimension)

            if r2 < se or j == j_rand:
              if clue_cost_k < position_cost:
                 position_p[i, j] = clue[k, j] + r1 *(position[i, j] - clue[k, j])
              else:
                position_p[i, j] = position[i, j] + r1 * (position[i, j] - clue[k, j])
            else:
              position_p[i,j] = position[i, j]

        else:
          r3 = np.random.rand()
          m = np.random.randint(0, 2 * self.population)
          while m==i or m == k:
            m = np.random.randint(0, 2 * self.population)
          position_p[i] = position[i] + r3*(clue[k] - clue[m])

        for j in range(self.dimension):
          position_p[i,j] = self.bound(position_bound[j], position[i, j], position_p[i, j])
          position_p[i,j] = self.find_nearest(section_int, position_p[i,j])

        position_p_cost = self.get_weight(self.truss, position_p[i], self.section_list, self.section_variable)
        stress = self.truss.stress
        displacement = self.truss.displacement

        position_p_cost = self.constraint(position_p_cost, self.truss, stress, self.stress_lim,
                                            displacement, self.disp_lim, it, self.iteration)
          
        memory, position[i], usn[i] = self.update_info(position[i], position_cost, position_p[i],
                                                         position_p_cost, memory, self.population, usn[i])
          
        if usn[i] > mu:
          for j in range(self.dimension):
            r4 = np.random.randint(0, self.dimension)
            position[i, j] = position_bound[j, 0] + r4*(position_bound[j, 1] - position_bound[j, 0])
            position_p[i, j] = self.find_nearest(section_int, position_p[i, j])
          usn[i]=0

        clue = np.concatenate([position,memory])

        x_cost = np.zeros(self.population)

        for i in range(self.population):
          x_cost[i] = self.get_weight(self.truss, position[i], self.section_list, self.section_variable)
          
        self.gbest[it+1] = position[np.argmin(x_cost)]
        self.gbest_cost[it+1] = np.min(x_cost)
    print(clue)

#function to run the optimization the number of times required

  def perform(self, run_number):
    gbest_list = np.zeros([run_number, self.dimension])
    gbest_cost_list = np.zeros(run_number)
    gbest_cost_iteration_list = np.zeros([run_number, self.iteration +1])
    for i in range(run_number):
        self.optimization()
        gbest_list[i] = self.gbest[-1]
        gbest_cost_list[i] = self.gbest_cost[-1]
        gbest_cost_iteration_list[i] = self.gbest_cost

    gbest_index = np.argmin(gbest_cost_list)
    gbest_cost = gbest_cost_list[gbest_index]
    gbest_cost_iteration = gbest_cost_iteration_list[gbest_index]
    gbest_cost_mean = np.zeros(self.iteration +1)

    for i in range(self.iteration + 1):
        gbest_cost_mean[i] = np.mean(gbest_cost_iteration_list[: i])

#displaying the results and plots for better understanding

    np.set_printoptions(precision=4, suppress=True)
    print('Member Stresses (ksi)')
    print(self.truss.stress[np.newaxis].T)
    print('Joint Displacement (in)')
    print(self.truss.displacement)
    print('Member Sections (in^2)')
    print(self.truss.section[np.newaxis].T)
    print('Total weigtht of truss = {:.4f} (lbs)'.format(gbest_cost))
    self.truss.undeformed(['red','-', 1])

    plt.figure('Convergence Curve')
    plt.plot(gbest_cost_iteration, label='Best cost', color='r')
    plt.plot(gbest_cost_mean, label= 'Mean cost', color='b')
    plt.xlabel('Iteration')
    plt.ylabel('Weight (lbs)')

#Properties of the truss structure and importing the data
modulus_elasticity = 1e4
material_density = 0.1

nodes =np.array([[-37.5, 0, 200],
                    [37.5, 0, 200],
                    [-37.5, 37.5, 100],
                    [37.5, 37.5, 109],
                    [37.5, -37.5, 100],
                    [-37.5, -37.5, 100],
                    [-100, 100, 0],
                    [100, 100, 0],
                    [100, -100, 0],
                    [-100, -100, 0]])

bars = np.array([[0,1],
                 [3,0],
                 [2,1],
                 [4,0],
                 [5,1],
                 [3,1],
                 [4,1],
                 [2,0],
                 [5,0],
                 [5,2],
                 [4,3],
                 [2,3],
                 [5,4],
                 [9,2],
                 [6,5],
                 [8,3],
                 [7,4],
                 [6,3],
                 [7,2],
                 [9,4],
                 [8,5],
                 [9,5],
                 [6,2],
                 [7,3],
                 [8,4]])

truss_1 = Truss(modulus_elasticity, material_density, nodes, bars)

#case wise load applied

loads = truss_1.load

loads[0, 0] = 1
loads[0, 1] = 10
loads[0, 2] = -5
loads[1, 1] = 10
loads[1, 2] = -5
loads[2, 0] = 0.5
loads[5, 0] = 0.5

#support : for calculation of degrees of freedom

supports = truss_1.support
supports[6,:]=0
supports[7,:]=0
supports[8,:]=0
supports[9,:]=0

#section follows the data where the optimization chooses from

section = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2, 2.1, 2.2, 2.3, 2.4, 2.6, 2.8, 3, 3.2, 3.4])

#defines which variable is for which element

section_var = np.array([[0,0],
                        [1,1],
                        [1,2],
                        [1,3],
                        [1,4],
                        [2,5],
                        [2,6],
                        [2,7],
                        [2,8],
                        [3,9],
                        [3,10],
                        [4,11],
                        [4,12],
                        [5,13],
                        [5,14],
                        [5,15],
                        [5,16],
                        [6,17],
                        [6,18],
                        [6,19],
                        [6,20],
                        [7,21],
                        [7,22],
                        [7,23],
                        [7,24]])

stress_limit = 40
disp_limit = 0.35

#the value of population and number iof iterations

pop = 10
iter_no = 5

#the optimization runs for 5 times

run_no = 5

op_1 = SAR(truss_1, section, section_var, pop, iter_no, stress_limit, disp_limit)
op_1.perform(run_no)

